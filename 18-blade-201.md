# Blade 201

Maintenant que nous connaissons les techniques d'authentification, nous pouvons explorer `blade` plus en profondeur.

Un raccourci pour la section `title` des pages : 
```blade
@section('title', 'Lire l\'article' . $article->title)
```
Raccourci qui nous √©vite d'√©crire `@endsection`, moins on en fait mieux on se porte üòÅ.  

Dans les vues, si on n'a pas de `content` (ou autre) dans la directive `@yield('content')`, on affichera la vue `view.name` :
```blade
@yield('content', View::make('view.name'))
```

Dans blade, on peut passer directement le r√©sultat d'une fonction PHP tant que c'est une 'string' :
```blade
{{ time() }}.
```

Dans les balises `<script>`, pour remplacer json_encode($array) :
```blade
@json($array)
```
Toujours avec javascript et blade, si vous ne voulez pas interpr√©ter une variable JS car votre framework JS utilise aussi la syntaxe moustache, le `@` dira √† laravel de ne pas interpr√©ter la variable :
```blade
@{{ variable-js }}
```
Si vous avez une page qui contient beaucoup de JS, √©vitez les `@` et ajoutez la directives :
```blade
@verbatim
    {{ variable-js }}
@endverbatim
```

---

Pour √©viter les encha√Ænements `@if` `@else` etc : 
```blade
@unless( $count > 10)
{{-- --}}
@endunless

@unless( Auth::check())
{{-- --}}
@endunless

@isset($variable)
{{-- --}}
@endisset

@empty($variable)
{{-- --}}
@endempty
```

---
On a d√©j√† vu `@auth` / `@endauth` qui remplace `@if(Auth::check()) ...`, on a aussi `@guest` / `@endguest`. : 
```blade
@if(Auth::guest())
{{-- Si l'utilisateur n'est pas authentifi√© --}}
@else
{{-- Sinon --}}
@endif

{{-- est √©quivalent √† --}}
@guest
{{-- --}}
@endguest
```

--- 

D'autres directives sont disponibles et nous ne pouvons pas tout lister ici.  
Enfin, sachez que sur le mod√®le de `vue.js`, il est possible de cr√©er des composants `blade`, qu'on r√©f√©rence avec des tags custom. N√©anmoins, cela va au dela de notre introduction √† laravel et vous saurez sans nul doute parcourir la documentation pour approfondir vos connaissances.


#### Authorizations
Une autre directive nous permet de v√©rifier les autorisations d'un utilisateur, la directive `@can()`
Cette directive ne n√©cessite pas d'√©crire un middleware mais tout ceci fonctionne ensemble. **Nous allons donc faire les deux**.

##### Custom middleware

Partons du principe que seul un administrateur peut √©crire, √©diter, ou effacer des articles.
Pour cr√©er un middleware on a une commande `artisan`
```bash
php artisan make:middleware Admin 
```
Cette commande va cr√©er un fichier `Admin.php` dans le dossier `Http/Middleware` avec une structure de base. Il nous reste √† ajouter le comportement de ce middleware √† la m√©thode `handle` :
```php
public function handle(Request $request, Closure $next)
{
    if(! auth()->check() || ! auth()->user()->isAdmin() ){
        return redirect('/')->with('error_message', 'Page not found');
    }
    return $next($request);
}
```
Cette m√©thode est simple. Si l'utilisateur n'a pas l'autorisation de naviguer sur la page, on le redirige avec un message d'erreur.
> On n'oublie pas de cr√©er la m√©thode `isAdmin()` dans le mod√®le `User`.

```php
    //Ajout 
    public function isAdmin()
    {
        return $this->admin;
    }
```

On peut d√©sormais prot√©ger les routes directement ainsi :
 ```php
Route::get('/articles/create', [ArticlesController::class, 'create'])->middleware(Admin::class);
Route::post('/articles/create', [ArticlesController::class, 'store'])->middleware(Admin::class);
```
Une autre alternative est de d√©finir un alias pour notre middleware.

Ouvrez le fichier `bootstrap/app.php` et enregistrez votre middleware. Voici comment faire :

```php
->withMiddleware(function (Middleware $middleware) {
        // Enregistrement du middleware avec un alias 'admin'
        $middleware->alias([
            'admin' => Admin::class, // Utilisez un tableau pour enregistrer l'alias
        ]);
    })
```

On peut apporter les modifications suivantes √† nos routes pr√©c√©dentes 
 ```php
Route::get('/articles/create', [ArticlesController::class, 'create'])->middleware("admin"); //Remplacement de la class Admin par l'alias d√©sign√©
Route::post('/articles/create', [ArticlesController::class, 'store'])->middleware("admin");
```

#####  Gate / @can directive 
Maintenant faisons en sorte d'utiliser la directive `@can` pour cacher les liens.  
Ouvrez le fichier `app/Providers/AppServiceProvider.php` et dans la m√©thode `boot()`, on ajoute ces quelques lignes :
```php
use Gate; //Au dessus de la class AppServiceProvider

public function boot()
{
    // $this->registerPolicies();

    Gate::define('see-admin-menu', function ($user) {
        return $user->isAdmin();
    });
}
```

Dans le fichier `master.blade.php`, on peut se servir de notre nouvelle directive :
```blade
@can('see-admin-menu')
    <a href="/articles/create">Cr√©er un article</a>
@endcan
```
Cette route est dor√©navant prot√©g√©e par un middleware et est masqu√©e par une directive `blade` que nous avons impl√©ment√©.

##### Policies

On se souvient que les articles ont un auteur. Admettons que seul l'auteur de l'article puisse √©diter ou effacer un article.
Pour nous faciliter la t√¢che, on impl√©mente une 'policy'.
```bash
php artisan make:policy ArticlePolicy --model=Article
```
Apr√®s cette commande, un dossier `app/Policies` a √©t√© cr√©e et il contient notre classe.
Cette classe contient d√©j√† des m√©thodes. Notre seul travail est de leur dire quoi faire. Nous nous servirons uniquement des m√©thodes `create`, `update` et `destroy`.  
- Pour autoriser la cr√©ation, nous devons nous assurer que l'utilisateur est un 'admin'.
- Pour autoriser la mise √† jour et l'effacement d'articles, nous v√©rifions que l'utilisateur est l'auteur de l'article.

Voici la m√©thode `create` :
```php
public function create(User $user)
{
    return $user->isAdmin();
}
```
Rien de compliqu√© ! Dans la mesure o√π, nous avons  d√©j√† la m√©thode `isAdmin()`, nous allons juste nous en servir.

Voici la m√©thode `update` :
```php
public function update(User $user, Article $article)
{
    return $user->isAdmin() && $user->id === $article->user_id;
}
```
On v√©rifie que le champ '`id`' de l'utilisateur et le champ '`user_id`' de l'article correspondent.

Pour La m√©thode `delete`, ce sera la m√™me chose.  
Ensuite, on ouvre le fichier `app/Providers/AppServiceProvider`, et on ajoute les lignes suivantes √† notre m√©thode `boot` :
```php
  public function boot(): void
    {
        //
        Gate::define('create', [ArticlePolicy::class, 'create']);
        Gate::define('update', [ArticlePolicy::class, 'update']);
        Gate::define('delete', [ArticlePolicy::class, 'delete']);
    }
```
Maintenant qu'on a ces m√©thodes, on s'en sert dans le contr√¥leur.

Modifications dans `ArticleController` :

```php
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;


class ArticlesController extends Controller implements HasMiddleware
{

   //ajouter
   use AuthorizesRequests; // Incluez le trait pour avoir acc√®s √† authorize()

}
```

### Arr√™t sur les traits (rappel)

* **H√©ritage en PHP**
   * **H√©ritage Simple** : En PHP, une classe ne peut h√©riter que d'une seule autre classe. Cela signifie que vous ne pouvez pas cr√©er une hi√©rarchie complexe d'h√©ritage avec plusieurs classes parentes.
* **Traits**

   * **R√©utilisation de Code** : Les traits permettent de partager des m√©thodes et des propri√©t√©s entre plusieurs classes. Cela signifie qu'une classe peut "`h√©riter`" de comportements d√©finis dans plusieurs traits, ce qui compense la limitation de l'h√©ritage simple.
* **Avantages des Traits**
   * **Comportements Multiples** : Gr√¢ce aux traits, une classe peut b√©n√©ficier de plusieurs comportements ou fonctionnalit√©s en m√™me temps, sans avoir √† cr√©er une hi√©rarchie d'h√©ritage complexe.
   * **Modularit√©** : Les traits permettent d'organiser le code de mani√®re modulaire, facilitant la r√©utilisation et la maintenance.

* **Exemple** 
```php
trait Logger {
    public function log($message) {
        echo "Log: $message";
    }
}

trait Notifier {
    public function notify($message) {
        echo "Notify: $message";
    }
}

class User {
    use Logger, Notifier; // La classe User utilise les traits Logger et Notifier

    public function performAction() {
        $this->log("Action performed");
        $this->notify("User notified");
    }
}

$user = new User();
$user->performAction();
```

Dans les m√©thodes `create()` et `store`, on ajoute une ligne :   

```php
public function create()
{
    $this->authorize('create', Article::class);
    // ...
}

public function store(Request $request)
{
    $this->authorize('create', Article::class);
    // ...
}
```
Dans les m√©thodes `edit`, `update` et `destroy`, on ajoute √©galement une seule ligne : 
```php
public function edit(Article $article)
{
    $this->authorize('update', $article);
    // ...
}
    
public function update(Request $request, Article $article)
{
    $this->authorize('update', $article);
    // ...
}

public function destroy(Article $article)
{
    $this->authorize('delete', $article);
    // ...
}
```

Petite modification √† apporter dans la m√©thode `store` dans `ArticlesController`

```php

public function store(Request $request)
   { 
      //$user = User::find(1); A remplacer
      $user = auth()->user(); //On r√©cup√®re l'utilisateur connect√© 

   }
```
C'est fait, nos resources sont prot√©g√©es. Si vous une mise √† jour sans y √™tre autoris√©, une erreur `403` sera retourn√©e.

***On n'√©tait pas oblig√© de faire une m√©thode pour la cr√©ation d'article vu qu'on a un middleware en place, mais dans le domaine de la s√©curit√©, plus il y a de couches, mieux c'est.*** 

Enfin, dans les template `blade`, on peut se servir de nos m√©thodes ainsi : 
```blade
{{-- le mod√®le User contient une m√©thode 'can' et une m√©thode 'cant' ... --}}
@auth
    @if( auth()->user()->can('create', 'App\Models\Article'))
        <a href="/articles/create">Cr√©er un article</a>
    @endif
@endauth
{{-- ou --}}
@can('create', 'App\Models\Article')
   <a href="/articles/create">Cr√©er un article</a>
@endcan
```
